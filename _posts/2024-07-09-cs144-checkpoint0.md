---
layout: single
title:  "cs144 checkpoint0"
date:  2024-07-09
categories: cs144
---
## 问题 1: 
`bytestream` 使用什么数据结构？
1. 原始想法： 使用环形队列，因为容量是固定的，使用环形队列的两头，一头读，一头写，而且还是原地算法，真的很不错。最大的缺点是： index 不好确定，尾可能在头的前面，不好计算。刚开始没弄明白 peek() 函数是干嘛的，还觉得是环形队列的问题，很难评，有时间把这种实现一下。
2. 第二想法： 使用 `vector`，使用  vector 不能从头部删除，需要自己手动维护。从这里开始从循环队列原地算法的圈套中走出来了，可以不只是用那一块内存，只要容量固定就行。可是我还是很古板，还是觉得这样应该会浪费内存。
3. 第三想法：使用 `deque`，使用 `deque` 的 `pop_front()` 函数，可以把头部数据删除，而且 `deque` 只从第一个有效位开始算头部，不会算之前 `pop` 出去的数据，这就很符合要求。

## 问题 2:
`string_view` 是什么？`peek()` 函数返回的 `string_view` 到底是哪一个？
1. 原始想法：`peek()` 返回的是当前 `buffer` 的视图，所以我就把 `deque` 中的元素全都拷贝到 string 当中，然后从 `string` 中生成 `string_view`，所以在运行测例的时候，我不出意外的遇到了栈上内存在返回时未释放的错误。
2. 第二想法：实在想不出来了，去 github 上看一个小哥，他的逻辑是 `peek()` 返回的是上一个 `push` 进的字符串的视图。按照这种思路去实现就很麻烦，因为要单独维护一个队列记录每一次 `push` 进来的字符串的视图。而且 `pop` 的时候又不是按照这个 `push` 进的字符串的粒度，所以 `pop` 操作的时候贼麻烦，而且我真的不清楚维护这样的视图有什么作用。于是我的直觉不是这样的。
3. 第三想法：看了一下 hint，然后感觉应该是 `buffer` 中下一个字符的视图，感觉这样就比较简单了。并且更加符合平时的直觉。